<!doctype html>
<html>
  <head>
    <title>Viz Server</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes" />
    <meta charset="utf-8">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.min.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/dc/2.1.0-dev/dc.css" rel="stylesheet">
    <style>
      div.dc-chart {
        float: none !important;
      }
      .dc-chart g.row text {
        text-shadow: 1px 1px #000000;
      }

    </style>
  </head>
  <body>
     <nav class="navbar navbar-light bg-faded">
      <a class="navbar-brand" href="#">SparkStreaming ML</a>
      <ul class="nav navbar-nav">
        <li class="nav-item active">
          <a class="nav-link" href="#">Home <span class="sr-only"></span></a>
        </li>
        <li class="nav-item active">
          <a class="nav-link" href="/description">Description <span class="sr-only"></span></a>
        </li>
      </ul>
      <form class="form-inline navbar-form pull-right hidden-xs">
        <input class="form-control" id="filter-all" type="text" placeholder="Filter">
        <button class="btn btn-success-outline" id="clear-filters">Clear</button>
      </form>
    </nav>

    <div class="container-fluid">
      <div class="row">
        <div class="col-xl-12 col-sm-12">
          <div class="card">
            <div class="card-header">
              Trades By Location
            </div>
            <div class="card-block">
              <div id="main-chart"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="row">
       <div class="col-xl-4 col-sm-12">
          <div class="card">
            <div class="card-header">
              Trades By Clearing House
            </div>
            <div class="card-block">
              <div id="second-chart"></div>
            </div>
          </div>
        </div>
        <div class="col-xl-4 col-md-6 col-sm-12">
          <div class="card">
            <div class="card-header">
              Trades By Category
            </div>
            <div class="card-block">
              <div id="minor-chart"></div>
            </div>
          </div>
        </div>
        <div class="col-xl-4 col-md-6 col-sm-12">
          <div class="card">
            <div class="card-header">
              Mean Price Over Time
            </div>
            <div class="card-block">
              <div id="second-minor-chart"></div>
            </div>
          </div>
        </div>
      </div>

    <div class="row">
       <div class="col-xl-4 col-sm-12">
          <div class="card">
            <div class="card-header">
              Trades By Cluster
            </div>
            <div class="card-block">
              <div id="second-cluster-chart"></div>
            </div>
          </div>
        </div>
        <div class="col-xl-4 col-md-6 col-sm-12">
          <div class="card">
            <div class="card-header">
              Cluster By Category
            </div>
            <div class="card-block">
              <div id="minor-cluster-chart"></div>
            </div>
          </div>
        </div>
        <div class="col-xl-4 col-md-6 col-sm-12">
          <div class="card">
            <div class="card-header">
              Cluster Movement Over Time
            </div>
            <div class="card-block">
              <div id="second-minor-cluster-chart"></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crossfilter/1.3.12/crossfilter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dc/2.1.0-dev/dc.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.6.7/d3-tip.min.js"></script>

    <script>

      var socket = io();
      var ChartViz = function() {
        this.updateDelay = 2000;
        this.charts = {};
        this.lastUpdate = new Date();
        this.data = { };
        this.colours = {
          greens: ['rgb(247,252,245)','rgb(229,245,224)','rgb(199,233,192)','rgb(161,217,155)','rgb(116,196,118)','rgb(65,171,93)','rgb(35,139,69)','rgb(0,109,44)','rgb(0,68,27)'],
          blues: ['rgb(255,247,251)','rgb(236,231,242)','rgb(208,209,230)','rgb(166,189,219)','rgb(116,169,207)','rgb(54,144,192)','rgb(5,112,176)','rgb(4,90,141)','rgb(2,56,88)'],
          redGreen: ['rgb(215,48,39)','rgb(244,109,67)','rgb(253,174,97)','rgb(254,224,139)','rgb(255,255,191)','rgb(217,239,139)','rgb(166,217,106)','rgb(102,189,99)','rgb(26,152,80)'],
          category: ['rgb(166,206,227)','rgb(31,120,180)','rgb(178,223,138)','rgb(51,160,44)','rgb(251,154,153)','rgb(227,26,28)','rgb(253,191,111)','rgb(255,127,0)','rgb(202,178,214)'],
          clusters: [
              'rgba(166,206,227,0.8)','rgba(31,120,180,0.8)','rgba(178,223,138,0.8)','rgba(51,160,44,0.8)','rgba(251,154,153,0.8)', // normal dots
              'rgb(166,206,227)','rgb(31,120,180)','rgb(178,223,138)','rgb(51,160,44)','rgb(251,154,153)' // centers
            ]
        };

        this.geoJson = {};

        this.setGeoJson = function(json) {
          this.geoJson = json;
          return this;
        };

        this.filterAll = function (text) {
          for (dataName in this.data) {
            this.data[dataName].dimensions.all.filter(function(d){return d.toLowerCase().indexOf(text.toLowerCase()) > -1;});
          }
          dc.redrawAll();
          return this;
        };

        this.clearFilters = function() {
          for (dataName in this.data) {
            for (dimensionName in this.data[dataName].dimensions) {
              this.data[dataName].dimensions[dimensionName].filterAll();
            }
            dc.filterAll(dataName);
          }
          dc.redrawAll();
          return this;
        }

        this.addData = function(dataName, data) {
          if (Object.prototype.toString.call( data ) != '[object Array]' ) {
              data = [data];
            }
          if (this.data[dataName] && this.data[dataName].cf) {
            this.data[dataName].cf.add(data);
          } else {
            this.data[dataName] = {};
            this.data[dataName].cf = new crossfilter(data);
            this.data[dataName].rendered = false;
            this.addDimension(dataName, 'all', function (d) {return Object.keys(d).map(function(k){ return d[k];}).join(''); });
          }

          if (this.data[dataName].cf.size() > 2) {
            if (!this.data[dataName].rendered) {
              dc.renderAll(dataName);
              this.data[dataName].rendered = true;
            } else if (new Date() - this.lastUpdate > this.updateDelay) {
              dc.redrawAll(dataName);
              this.lastUpdate = new Date();
            }
          }
          return this;
        };

        this.addDimension = function(dataName, dimensionName, dimension, grouping) {
          if (!dimension) dimension = dimensionName;
          if (typeof dimension == 'string') {
            dimension = function(d) {return d[dimension];};
          }
          this.addData(dataName,[]);
          this.data[dataName].dimensions = this.data[dataName].dimensions || {};
          this.data[dataName].groups = this.data[dataName].groups || {};
          this.data[dataName].dimensions[dimensionName] = this.data[dataName].cf.dimension(dimension);

          if (grouping) {
            if (typeof grouping == 'string') {
              this.data[dataName].groups[dimensionName] = this.data[dataName].dimensions[dimensionName].group().reduceSum(function (d) {
                  return d[grouping];
              });
            } else {
              this.data[dataName].groups[dimensionName] = this.data[dataName].dimensions[dimensionName].group().reduce(grouping.sum,grouping.sub,grouping.init);
            }
          } else {
            this.data[dataName].groups[dimensionName] = this.data[dataName].dimensions[dimensionName].group();
          }

          return this;
        };

        this.initCharts = function() {
          var self = this;
          var projection = d3.geo.mercator()
              .scale(($('#main-chart').parent().width() + 1) / 2 / Math.PI)
              .translate([$('#main-chart').parent().width() / 2, 500 / 2])
              .precision(.1);
//              .center([133,-28]) //this is aus
//              .scale(700) //fills about 500px high for aus
//              .rotate([-12,0]);

          /*Init charts */
          this.charts.country = dc.geoChoroplethChart('#main-chart', 'trades')
                                  .height(500)
                                  .dimension(this.data.trades.dimensions.country)
                                  .group(this.data.trades.groups.country)
                                  .colors(d3.scale.category10())
                                  .colorDomain([0, 4000])
                                  .colorCalculator(function (d) {
                                      var a = self.data.trades.groups.country.top(Infinity).map(function(d){return d.value}).reverse();
                                      return d ? self.colours.redGreen[Math.round(((self.colours.redGreen.length-1)/a.length) * a.indexOf(d))] : '#ccc';
                                    })
                                  .overlayGeoJson(this.geoJson.features, "country", function (d) {
                                      return d.properties.name;
                                  })
                                  .projection(projection)
                                  .title(function (d) {
                                      return  d.key + "\nTotal Trades: " + (d.value ? d.value : 0);
                                  });
          //this.charts.cluster = dc.bubbleChart("#second-chart").chartGroup('trades_test');
          this.charts.category = dc.rowChart("#minor-chart",'trades')
                                    .height(500)
                                    .margins({top: 30, right: 50, bottom: 25, left: 40})
                                    .dimension(this.data.trades.dimensions.category)
                                    .group(this.data.trades.groups.category)
                                    .ordering(function(d){ return -d.value })
                                    .cap(16)
                                    // assign colors to each value in the x scale domain
                                    //.ordinalColors(d3.scale.category10())
                                    .label(function (d) {
                                        return d.key + ': ' + d.value;//key.split(".")[1];
                                    })
                                    // title sets the row text
                                    .title(function (d) {
                                        return d.key;
                                    })
          this.charts.category
                                    .elasticX(true)
                                    .xAxis().ticks(5);

          this.charts.bubbles = dc.bubbleChart("#second-chart", "trades")
                                    //.width(990) // (optional) define chart width, :default = 200
                                    .height(500)  // (optional) define chart height, :default = 200
                                    .transitionDuration(1000) // (optional) define chart transition duration, :default = 750
                                    .margins({top: 10, right: 50, bottom: 30, left: 40})
                                    .dimension(this.data.trades.dimensions.ccp)
                                    //Bubble chart expect the groups are reduced to multiple values which would then be used
                                    //to generate x, y, and radius for each key (bubble) in the group
                                    .group(this.data.trades.groups.ccp)
                                    .colors(this.colours.category) // (optional) define color function or array for bubbles
                                    //.colorDomain([-20, 0]) //(optional) define color domain to match your data domain if you want to bind data or color
                                    //.ordering(function(d){ return -d.value.sales_count; })
                                    //##### Accessors
                                    //Accessor functions are applied to each value returned by the grouping
                                    //
                                    //* `.colorAccessor` The returned value will be mapped to an internal scale to determine a fill color
                                    //* `.keyAccessor` Identifies the `X` value that will be applied against the `.x()` to identify pixel location
                                    //* `.valueAccessor` Identifies the `Y` value that will be applied agains the `.y()` to identify pixel location
                                    //* `.radiusValueAccessor` Identifies the value that will be applied agains the `.r()` determine radius size, by default this maps linearly to [0,100]
                                    .colorAccessor(function (d) {
                                        return chartManager.data.trades.groups.ccp.all().map(function(d) {return d.key}).indexOf(d.key)%9;
                                    })
                                    .colorAccessor(function (d) {
                                        return chartManager.data.trades.groups.ccp.all().map(function(d) {return d.key}).indexOf(d.key)%9;
                                    })
                                    .colorDomain([1, 9])
                                    .keyAccessor(function (p) {
                                        return p.value.avgPrice;
                                    })
                                    .valueAccessor(function (p) {
                                       return p.value.volume;
                                    })
                                    .radiusValueAccessor(function (p) {
                                        return p.value.totalValue;
                                    })
                                    .x(d3.scale.sqrt().domain([0, this.data
                                                                        .trades
                                                                        .groups
                                                                        .ccp
                                                                        .order(function(d){
                                                                          return d.avgPrice;
                                                                        }).top(1)
                                                                        .reduce(function(l,c){
                                                                          return c || l;
                                                                        },{value:{avgPrice:0}}).value
                                                                        .avgPrice*1.2]))
                                    .y(d3.scale.sqrt().domain([0, this.data
                                                                        .trades
                                                                        .groups
                                                                        .ccp
                                                                        .order(function(d){
                                                                          return d.volume;
                                                                        }).top(1)
                                                                        .reduce(function(l,c){
                                                                          return c || l;
                                                                        },{value:{volume:0}}).value
                                                                        .volume*1.2]))
                                    .r(d3.scale.linear().domain([this.data
                                                                        .trades
                                                                        .groups
                                                                        .ccp
                                                                        .order(function(d){
                                                                          return -d.totalValue;
                                                                        }).top(1)
                                                                        .reduce(function(l,c){
                                                                          return c || l;
                                                                        },{value:{totalValue:0}}).value
                                                                        .totalValue,
                                                                 this.data
                                                                        .trades
                                                                        .groups
                                                                        .ccp
                                                                        .order(function(d){
                                                                          return d.totalValue;
                                                                        }).top(1)
                                                                        .reduce(function(l,c){
                                                                          return c || l;
                                                                        },{value:{totalValue:0}}).value
                                                                        .totalValue]))
                                    //##### Elastic Scaling
                                    //`.elasticX` and `.elasticX` determine whether the chart should rescale each axis to fit data.
                                    //The `.yAxisPadding` and `.xAxisPadding` add padding to data above and below their max values in the same unit domains as the Accessors.
                                    .elasticY(true)
                                    .elasticX(true)
                                    .elasticRadius(true)
                                    .maxBubbleRelativeSize(0.15)
                                    .yAxisPadding(30)
                                    .xAxisPadding(100)
                                    .renderHorizontalGridLines(true) // (optional) render horizontal grid lines, :default=false
                                    .renderVerticalGridLines(true) // (optional) render vertical grid lines, :default=false
                                    .xAxisLabel('Price per Unit') // (optional) render an axis label below the x axis
                                    .yAxisLabel('Volume of Trades') // (optional) render a vertical axis lable left of the y axis
                                    //#### Labels and  Titles
                                    //Labels are displaed on the chart for each bubble. Titles displayed on mouseover.
                                    .renderLabel(true) // (optional) whether chart should render labels, :default = true
                                    .label(function (p) {
                                        return p.key;
                                    })
                                    .renderTitle(true) // (optional) whether chart should render titles, :default = false
                                    .title(function (p) {
                                        return [p.key,
                                               "Average Price: " +  d3.format("$,.2f")(p.value.avgPrice),
                                               "Volume: " + d3.format(",")(p.value.volume),
                                               "Total Value of Trades: " + d3.format("$.3s")(p.value.totalValue)]
                                               .join("\n");
                                    });

          this.charts.bubbles.yAxis().tickFormat(d3.format(".3s"));
          this.charts.bubbles.xAxis().tickFormat(d3.format("$,.2f"));

          this.charts.bubbles2 = dc.bubbleChart("#second-cluster-chart", "kmstats")
                                    //.width(990) // (optional) define chart width, :default = 200
                                    .height(500)  // (optional) define chart height, :default = 200
                                    .transitionDuration(1000) // (optional) define chart transition duration, :default = 750
                                    .margins({top: 10, right: 50, bottom: 30, left: 40})
                                    .dimension(this.data.kmstats.dimensions.party_w)
                                    //Bubble chart expect the groups are reduced to multiple values which would then be used
                                    //to generate x, y, and radius for each key (bubble) in the group
                                    .group(this.data.kmstats.groups.party_w)
                                    .colors(this.colours.clusters) // (optional) define color function or array for bubbles
                                    //.colorDomain([-20, 0]) //(optional) define color domain to match your data domain if you want to bind data or color
                                    //.ordering(function(d){ return -d.value.sales_count; })
                                    //##### Accessors
                                    //Accessor functions are applied to each value returned by the grouping
                                    //
                                    //* `.colorAccessor` The returned value will be mapped to an internal scale to determine a fill color
                                    //* `.keyAccessor` Identifies the `X` value that will be applied against the `.x()` to identify pixel location
                                    //* `.valueAccessor` Identifies the `Y` value that will be applied agains the `.y()` to identify pixel location
                                    //* `.radiusValueAccessor` Identifies the value that will be applied agains the `.r()` determine radius size, by default this maps linearly to [0,100]
                                    .colorAccessor(function (d) {
                                        return parseInt(d.key.split(":")[0]) + parseInt(d.key.split(":")[1])*5;
                                    })
                                    .colorDomain([1, 10])
                                    .keyAccessor(function (p) {
                                        var idx = p.key.split(":")[0]
                                        return p.value.prices[idx];
                                    })
                                    .valueAccessor(function (p) {
                                        var idx = p.key.split(":")[0]
                                        return p.value.weights[idx];
                                    })
                                    .radiusValueAccessor(function (p) {
                                        return 5;
//                                        var idx = p.key.split(":")[0]
//                                        return p.value.counts[idx];
                                    })
                                    .x(d3.scale.linear().domain([0, this.data
                                                                        .kmstats
                                                                        .groups
                                                                        .party_w
                                                                        .order(function(d){
                                                                           return d.price;
                                                                        }).top(1)
                                                                        .reduce(function(l,c){
                                                                          return c || l;
                                                                        },{value:{totalPrice:0}}).value
                                                                        .totalPrice*1.2]))
                                    .y(d3.scale.linear().domain([0, this.data
                                                                        .kmstats
                                                                        .groups
                                                                        .party_w
                                                                        .order(function(d){
                                                                           return d.party_w;
                                                                        }).top(1)
                                                                        .reduce(function(l,c){
                                                                          return c || l;
                                                                        },{value:{avgWeight:0}}).value
                                                                        .avgWeight*1.2]))
                                    .r(d3.scale.linear().domain([0,21/*this.data
                                                                        .kmstats
                                                                        .groups
                                                                        .party_w
                                                                        .order(function(d){
                                                                           return -d.price;
                                                                        }).top(1)
                                                                        .reduce(function(l,c){
                                                                          return c || l;
                                                                        },{value:{totalPrice:0}}).value
                                                                        .totalPrice,
                                                                 this.data
                                                                        .kmstats
                                                                        .groups
                                                                        .party_w
                                                                        .order(function(d){
                                                                           return d.price;
                                                                        }).top(1)
                                                                        .reduce(function(l,c){
                                                                          return c || l;
                                                                        },{value:{totalPrice:0}}).value
                                                                        .totalPrice*/]))
                                    //##### Elastic Scaling
                                    //`.elasticX` and `.elasticX` determine whether the chart should rescale each axis to fit data.
                                    //The `.yAxisPadding` and `.xAxisPadding` add padding to data above and below their max values in the same unit domains as the Accessors.
                                    .elasticY(true)
                                    .elasticX(true)
                                    .yAxisPadding(30)
                                    .xAxisPadding(100)
                                    .renderHorizontalGridLines(true) // (optional) render horizontal grid lines, :default=false
                                    .renderVerticalGridLines(true) // (optional) render vertical grid lines, :default=false
                                    .xAxisLabel('Price per Unit') // (optional) render an axis label below the x axis
                                    //.yAxisLabel('Volume of Trades') // (optional) render a vertical axis lable left of the y axis
                                    //#### Labels and  Titles
                                    //Labels are displaed on the chart for each bubble. Titles displayed on mouseover.
                                    .renderLabel(true) // (optional) whether chart should render labels, :default = true
                                    .label(function (d) {
                                        return "Cluster "+d.key.split(":")[0]
                                    })
                                    .renderTitle(true) // (optional) whether chart should render titles, :default = false
                                    .title(function (p) {
                                        var idx = p.key.split(":")[0]
                                        return [
//                                                p.key,
                                               "Cluster: " + idx,
                                               "Total Price: " +  d3.format("$,.2f")(p.value.prices[idx]),
                                               "Volume: " + d3.format(",")(p.value.counts[idx])
                                               ]
                                               .join("\n");
                                    });

          this.charts.bubbles2.yAxis().tickFormat(d3.format(".3s")).ticks(7);
          this.charts.bubbles2.xAxis().tickFormat(d3.format("$,.2f")).ticks(7);


          this.charts.timeLine = dc.lineChart("#second-minor-chart","trades")
                                  //.width(990)
                                  .height(500)
                                  .transitionDuration(1000)
                                  .margins({top: 30, right: 50, bottom: 25, left: 40})
                                  .dimension(this.data.trades.dimensions.time)
                                  .group(this.data.trades.groups.time,"Average Price")
                                  .xyTipsOn(true)
                                  .renderHorizontalGridLines(true)
                                  .legend(dc.legend().x(50).y(35).itemHeight(13).gap(5))
                                  .brushOn(false)
                                  // Add the base layer of the stack with group. The second parameter specifies a series name for use in the legend
                                  // The `.valueAccessor` will be used for the base layer
                                  .valueAccessor(function (d) {
                                      return d.value.avgPrice;
                                  })
                                  // stack additional layers with `.stack`. The first paramenter is a new group.
                                  // The second parameter is the series name. The third is a value accessor.

//                                  .stack(this.data.trades.groups.time, "Value 2", function (d) {
//                                      return d.value.1;
//                                  })
//                                  .stack(this.data.trades.groups.time, "Value 3", function (d) {
//                                      return d.value.2;
//                                  })
//                                  .stack(this.data.trades.groups.time, "Value 4", function (d) {
//                                      return d.value.3;
//                                  })
                                  // title can be called by any stack layer.
                                  .title(function (d) {
                                      var dao = d.data || d;
                                      return d3.time.format('%H:%M')(dao.key) + "\n"
                                              + 'Average Price: ' + (dao.value.avgPrice)
                                              ;
                                  })
                                  .elasticY(true)
                                  .elasticX(true)
                                  .y(d3.scale.pow().exponent(0.2).domain(
                                    d3.extent(chartManager.data.trades.groups.time.all(),
                                              function(d) {
                                                return d.value.avgPrice;
                                              })
                                  ))
                                  .x(d3.time.scale().domain(
                                    d3.extent(chartManager.data.trades.groups.time.all(),
                                              function(d) {
                                                return +d.key;
                                              }).map(function(d) {
                                                return new Date(d);
                                              })
                                  ))

          this.charts.timeLine.xAxis().tickFormat(d3.time.format('%H:%M:%S'));
          this.charts.timeLine.xAxis().ticks(5);
          this.charts.timeLine.yAxis().tickFormat(d3.format('$.3s'));

          var tip = d3.tip()
                  .attr('class', 'd3-tip')
                  .offset([-10, 0])
                  .html(function (d) {
                    //return "<span style='color: #f0027f'>" +  d.key + "</span> : "  + numberFormat(d.value);
                    return this;
                  });

          Object.keys(this.charts).forEach(function(k){
            self.charts[k].width($(self.charts[k].anchor()).parent().width())
          });
          return this;
        };
      };

      var chartManager = new ChartViz();

      var sanitiseStatsJson = function (json) {
          if (json.time) { json.time = parseInt(json.time); }
          return json;
      }
      var sanitiseStatsValue = function (value) {
          return value.replace(/[,]+\]/gi,']')
      };

      var getStatsRow = function (point, i, center) {
          return {
                "price": point[0],
                "cluster": i,
                "label": "Cluster "+i,
                "party_w": point[1],
                "exchange_w": point[2],
                "currency_w": point[3],
                "center": center,
                "cluster_cidx": i + (center ? 5 : 0)
            };
      };

      var getStatsData = function (json) {
          var data = [];
          json["cluster-centers"].forEach(function (cc, i) {
              var row = getStatsRow(cc, i, true);
              row.time = json.time;
              row.key = i+":1:0"
              data.push(row);
              if (!json["cluster-data"] || !json["cluster-data"][i]) { return; }
              json["cluster-data"][i].forEach(function (cd,j) {
                  var row = getStatsRow(cd, i, false);
                  row.time = json.time;
                  row.key = i+":0:"+(1+j)
                  data.push(row)
              });
          });
          return data;
      }

      var createStatsData = function (value) {
          var value = sanitiseStatsValue(value);
          var json = JSON.parse(value);
          return getStatsData(json);
      }

        chartManager
            .addDimension('kmstats','time',function(d) {return d.time;})
            .addDimension('kmstats','cluster',function(d) {return d.cluster;})
            .addDimension('kmstats','cluster_colour',function(d) {return d.cluster_cidx;})
            .addDimension('kmstats','price',function(d) {return d.price;})
            .addDimension('kmstats','party_w',function(d){return d.key;},{
                        init: function(){
                          return {prices:[0,0,0,0,0],counts:[0,0,0,0,0],weights:[0,0,0,0,0],totalPrices:[0,0,0,0,0],totalWeights:[0,0,0,0,0]};
                        },
                        sum: function(totalled,row){
                          var idx = row.cluster;
                          totalled.counts[idx] ++;
                          totalled.totalPrices[idx] += row.price;
                          totalled.totalWeights[idx] += row.party_w;
                          totalled.weights[idx] = totalled.totalWeights[idx]/totalled.counts[idx];
                          totalled.prices[idx] = totalled.totalPrices[idx]/totalled.counts[idx];
                          totalled.maxPrice = Math.max.apply(null, totalled.prices);
                          totalled.minPrice = Math.min.apply(null, totalled.prices)
                          totalled.maxWeight = Math.max.apply(null, totalled.weights);
                          totalled.minWeight = Math.min.apply(null, totalled.weights)
                          return totalled;
                        },
                        sub: function(totalled,row){
                          var idx = row.cluster;
                          totalled.counts[idx] --;
                          if (totalled.counts[idx] < 0) totalled.counts[idx] = 0;
                          totalled.totalPrices[idx] -= row.price;
                            if (totalled.totalPrices[idx] <0) totalled.totalPrices[idx] = 0;
                          totalled.totalWeights[idx] -= row.party_w;
                            if (totalled.totalWeights[idx] <0) totalled.totalWeights[idx] = 0;
                          totalled.weights[idx] = (totalled.counts[idx]>0?totalled.totalWeights[idx]/totalled.counts[idx]:0);
                          totalled.prices[idx] = (totalled.counts[idx]>0?totalled.totalPrices[idx]/totalled.counts[idx]:0);
                          totalled.maxPrice = Math.max.apply(null, totalled.prices);
                          totalled.minPrice = Math.min.apply(null, totalled.prices)
                          totalled.maxWeight = Math.max.apply(null, totalled.weights);
                          totalled.minWeight = Math.min.apply(null, totalled.weights)
                          return totalled;
                        }
                      })


      $.getJSON("https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json",function(world){
        //bermuda is buggered for some reason so skip it
        world.features = world.features.filter(function(d) {return d.properties.name != 'Bermuda';})
        var customMetrics = {
                        init: function(){
                          return {volume:0,avgPrice:0,totalValue:0,rowCount:0,totalPrice:0 };
                        },
                        sum: function(totalled,row){
                          totalled.rowCount++;
                          totalled.volume += row.volume;
                          totalled.totalValue += (row.price*row.volume);
                          totalled.totalPrice += row.price;
                          totalled.avgPrice = totalled.totalPrice/totalled.rowCount;
                          return totalled;
                        },
                        sub: function(totalled,row){
                          totalled.rowCount--;
                          totalled.volume -= row.volume;
                          totalled.totalValue -= (row.price*row.volume);
                          totalled.totalPrice -= row.price;
                          totalled.avgPrice = totalled.totalPrice/totalled.rowCount;
                          totalled.avgPrice = isNaN(totalled.avgPrice) ? 0 : totalled.avgPrice;
                          return totalled;
                        }
                      };
        chartManager.setGeoJson(world)
                      .addDimension('trades','country',function(d) {return d.country;})
                      .addDimension('trades','category',function(d) {return d.category && d.category.length ? d.category : ('General: ' + d.type + ' - ' + d.unit)})
                      .addDimension('trades','ccp',function(d){return d.ccp;},customMetrics)
                      .addDimension('trades','time',function(d){
                          var ttime = new Date(d.trade_time);
                          ttime.setSeconds(Math.round(ttime.getSeconds()/10)*10);
                          ttime.setMilliseconds(0);
                          return ttime;
                        },customMetrics)
                      .initCharts();
        $("#filter-all").on('keyup', function() {
          var filterString = $(this).val();
          chartManager.filterAll(filterString);
        });
        $("#clear-filters").on('click', function() {
          var filterString = $(this).val();
          chartManager.clearFilters();
          return false;
        });
          socket.on('trades', function(msg){
              try {
                chartManager.addData('trades',JSON.parse(msg.value))
              } catch (e) {
                console.warn(e);
              }
          });
          socket.on('kmstats', function(msg){
            if (msg) {
              try {
                var value = createStatsData(msg.value)
                if (chartManager.data['kmstats']) {
                    chartManager.data['kmstats'].cf.remove();
                }
                chartManager.addData('kmstats',value)
                //console.log(msg);
              } catch (e) {
                console.warn(e);
              }
            }
          });
      });

     // | trade_date   | trade_time   | party   | counterparty   | ccp   | exchange   | symbol   | currency   | side   | type   | category   | price   | volume   | unit   | country   | max_bank   | max_symbol   | max_country   | max_currency   | max_exchange   | party_weight   | counterparty_weight   | exchange_weight   | country_weight   | symbol_weight   | currency_weight   |

    </script>
  </body>
</html>
