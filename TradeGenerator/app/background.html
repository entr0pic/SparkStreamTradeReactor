<!doctype html>
<html>
  <head>
    <title>Viz Server</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes" />
    <meta charset="utf-8">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/c3/0.4.10/c3.min.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha/css/bootstrap.min.css" rel="stylesheet">
    <link href="http://cdnjs.cloudflare.com/ajax/libs/dc/1.7.0/dc.css" rel="stylesheet">
    <style>
      div.dc-chart {
        float: none !important;
      }
      .dc-chart g.row text {
        text-shadow: 1px 1px #000000;
      }
      g.type-TK > rect {
        fill: #00ffd0;
      }

      text {
        font-weight: 300;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
        font-size: 14px;
      }

      .node rect {
        stroke: #999;
        fill: #fff;
        stroke-width: 1.5px;
      }

      .edgePath path {
        stroke: #333;
        stroke-width: 1.5px;
      }
    </style>
  </head>
  <body>
     <nav class="navbar navbar-light bg-faded">
      <a class="navbar-brand" href="#">SparkStreaming ML</a>
      <ul class="nav navbar-nav">
        <li class="nav-item ">
          <a class="nav-link" href="/">Home <span class="sr-only"></span></a>
        </li>
        <li class="nav-item ">
          <a class="nav-link" href="/description">Description <span class="sr-only"></span></a>
        </li>
        <li class="nav-item active">
          <a class="nav-link" href="/background">Background <span class="sr-only"></span></a>
        </li>
      </ul>
      <form class="form-inline navbar-form pull-right hidden-xs">
        <input class="form-control" id="filter-all" type="text" placeholder="Filter">
        <button class="btn btn-success-outline" id="clear-filters">Clear</button>
      </form>
    </nav>

    <div class="container-fluid">
      <div class="row">
        <div style="height:20px;"></div>
      </div>
      <div class="row">
       <div class="col-xl-12 col-sm-12">
        <div class="card">
            <div class="card-header">
              Quick overview
            </div>
            <div class="card-block">
              <div>
                <p>This example system demonstrates the implementation of stream based dataflow using something similar to the Kappa architecture, the only thing stopping it from being pure Kappa is that SparkStreaming can only process streams discretely, i.e. it uses 'micro-batches'. Other than that every bit of data is delivered through a stream which is either persisted to HDFS or visualised by a client.</p>
                <p>The is a scalable 'Trade Generator' node which uses real seed values to generate randomised trades across a variety of products, countries, exchanges and currencies, the trades are immediately fed into a Kafka producer. Spark Streaming then consumes the feed and generates another derived stream which outputs kmeans clusting results. Spark Stream also persists these messages from these streams to HDFS.</p>
                <p>Theres is then another node.js based Kafka consumer subscribing to both the raw stream and the derived stream and translates both these streams into web-sockets using socket.io, by which a front end client subscribes to and consumers the messages via the socket. Each message consumed by the frontend client results in the re-rendering of all applicable visualisation to convey the last known state.</p>
                <p class="lead">Example of data flow through the system</p>
                <img src="/assets/data-flow.png" alt="Data flow" width="100%;">
              </div>
            </div>
          </div>
        </div>
      </div>
       <div class="row">
        <div class="col-xl-6 col-sm-12">
         <div class="card">
            <div class="card-header">
              Spark
            </div>
            <div class="card-block">
             <div style="height:40px;"><img src="/assets/spark-logo.png" style="width:150px ;float: right;"></div>
              <p class="lead">Spark Streaming in the wild</p>
              <p></p>
            </div>
          </div>
          <div class="card">
            <div class="card-header">
              Kafka
            </div>
            <div class="card-block">
              <div style="height:40px;"><img src="/assets/kafka-logo.png" style="float: right;"></div>
              <p class="lead">Why Kafka?</p>
              <p>Kafka is more than just a message broker, think of it as a message broker crossed with a distributed database and all the replication, scalability, fault tolerance and speed benefits that come with it.</p>
              <p>Kafka maintains a sequential commit log of all messages it recieves, akin to a write ahead log used for database replication. </p>
              <img src="/assets/kafka_log.png" alt="Kafka Log">
              <p>This means consumers can be stateful and replay messages in order from the last message they recieved in the commit log.</p>
              <p>On top of this Kafka was designed to handle incredibly high-throughput, it can <strong>"support high volume event streams such as real-time log aggregation"</strong>, it can <strong>"deal gracefully with large data backlogs to be able to support periodic data loads from offline systems"</strong> as well as handle <strong>"low-latency delivery to handle more traditional messaging use-cases"</strong>.</p>
              <p>This makes it the ideal ESB, allowing you to more effectively manage data pipelines across an organisation with tens to hundreds of systems.</p>
            </div>
          </div>
          <div class="card">
            <div class="card-header">
              Reactive Programming
            </div>
            <div class="card-block">
              <div>
                <p class="lead">Streams Everywhere!</p>
                <p>Reactive programming according to wikipedia is <strong>"is a programming paradigm oriented around data flows and the propagation of change"</strong>. And while theres a whole heap of definitions, the easiest way to think of it is treating <strong>everything</strong> as a stream of data. The means no more REST, the only way of getting data is subscribing to a stream and likewise all new data is published to a stream.</p>
                <p>This example of a trade monitoring system uses the reactive approach where all data is in a continuous stateful stream and that state is propagated to the UI as and when it changes. Technologies like Kafka on the backend, Spark, Storm and Samza as stream processing tools and things like socket.io which nicely wraps web sockets for the frontend, make developing reactive applications and systems simpler and easier</p>
                <p>Check out the </p><a href="http://www.reactivemanifesto.org/">Reactive Manifesto</a>
              </div>
            </div>
          </div>

        </div>

        <div class="col-xl-6 col-sm-12">
          <div class="card">
            <div class="card-header">
              Docker
            </div>
            <div class="card-block">
              <div>
                 <div style="height:40px;"><img src="/assets/docker-logo.png" style="float: right;"></div>
                <p class="lead">Hadoop on Docker?</p>
                <p>It may not be as crazy as it sounds, in fact one of the main reasons it was used for this project (aside from being fun to play with) was cost. Rather than provisioning VM instances for each box we would have needed in our multi-node hadoop cluster, we could provision a single mid-spec or low-spec box. From that single box we would be able to run our 14 containers. In fact the entire system can run on a single CPU box with 3.75gb of memory.</p>
                <p>So while this isn't the exact use case that you would be trying to replicate within a business, it shows you the efficiency you can get out of docker vs using standalone VMs. You vastly reduce the overhead of using VM's and it allows you to utilize every last bit of CPU memory on a given hardware stack.</p>
                <p>In fact, a <a href="http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/$File/rc25482.pdf">2014 study done by IBM</a> shows that <strong>"The general result is that Docker is nearly identical to Native performance and faster than KVM in every category."  </strong>, the one exception to this is network latency if you use dockers virtual NAT rather than giving the container access to the host NAT (which again performs virtually identically to the native host)</p>
                <img src="/assets/docker-throughput.png" alt="Docker Throuput" width="50%"><img src="/assets/docker-iops.png" alt="Docker IOPS" width="50%">
                <p class="lead">So how does it compare then?</p>
                <table class="table resplonsive">
                  <thead>
                    <tr>
                       <th>Cluster Type</th>
                      <th>Pure Speed</th>
                      <th>Multi-tenancy</th>
                      <th>Cost Efficiency</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Bare-Metal</td>
                      <td><strong>Best</strong></td>
                      <td><strong>Worst</strong> - Hard to provision and maintain isolated environments cheaply</td>
                      <td><strong>Most expensive</strong></td>
                    </tr>
                    <tr>
                      <td>Kernel-based Virtual Machine</td>
                      <td><strong>Slightly-Worse</strong></td>
                      <td><strong>Better</strong> - Managing and provisioning isolated environments with new nodes is easier, but introduces overhead for every VM provisioned</td>
                      <td><strong>Middle ground</strong></td>
                    </tr>
                    <tr>
                      <td>Docker</td>
                      <td><strong>Near-Best</strong></td>
                      <td><strong>Best</strong> - Quickest to provision and scale nodes (containers), easy to provision isolated network environments between clusters of contaiers and quick to spin up and spin down containers</td>
                      <td><strong>Cheapest</strong></td>
                    </tr>
                  </tbody>
                </table>
                <br />
                <p>Docker allows you to manage, monitor and provision more of the physically available compute compacity than you would normally be able to.</p>
                <p>Running docker on distributed set of physical hardware using a resource negotiator like YARN or MESOS can allow you to get more out of your hadoop implementation.</p>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="card-header">
              Some handy references
            </div>
            <div class="card-block">
              <div>
                <div><a href="https://www.youtube.com/watch?v=fU9hR3kiOK0">"Turning the database inside out with Apache Samza" by Martin Kleppmann</a></div>
                <div><a href="https://www.youtube.com/watch?v=fU9hR3kiOK0">"Putting Apache Kafka to Use for Event Streams" by Jay Kreps</a></div>
                <div><a href="http://radar.oreilly.com/2014/07/questioning-the-lambda-architecture.html">Questioning The Lambda Architecture</a></div>
                <div><a href="http://thenewstack.io/running-hadoop-docker-production-scale/">Running Hadoop on Docker, in Production and at Scale</a></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>




    <script src="http://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/js/bootstrap.min.js"></script>

  </body>
</html>
